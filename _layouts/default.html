<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {%- include head.html -%}

  <body>

    {%- include header.html -%}

      <div class="flex users">
          <div class="container flex--vertical">
            <div class="flex wrap">
              <div class="flex flex--vertical">
                <div class="flex item wrap">
                    <a href={{'/community' | relative_url}}>
                      <img src={{'/assets/icon-niwa.png' | relative_url}} class="icon-user niwa" alt="NIWA"/>
                      <img src={{'/assets/icon-metoffice.svg' | relative_url}} class="icon-user met" alt="Met Office"/>
                      <img src={{'/assets/icon-airforce.png' | relative_url}} class="icon-user airforce" alt="US Air Force"/>
                      <img src={{'/assets/icon-nrl-small.jpg' | relative_url}} class="icon-user nrl" alt="US Navy"/>
                      <img src={{'/assets/icon-agbom.jpeg' | relative_url}} class="icon-user agbom" alt="AGBOM"/>
                      <img src={{'/assets/icon-csiro.png' | relative_url }} class="icon-user csiro" alt="CSIRO"/>
                      <img src={{'/assets/icon-moes.jpeg' | relative_url}} class="icon-user moes" alt="MOES"/>
                      <img src={{'/assets/icon-altair.png' | relative_url}} class="icon-user altair" alt="Altair"/>
                      <img src={{'/assets/icon-icm.png' | relative_url}} class="icon-user icm" alt="ICM"/>
                      <img src={{'/assets/icon-korea.png' | relative_url}} class="icon-user korea" alt="Korea"/>
                      <img src={{'/assets/icon-coecss.png' | relative_url}} class="icon-user coecss" alt="COECSS"/>
                      <img src={{'/assets/icon-mets.png' | relative_url}} class="icon-user mets" alt="METS"/>
                      <img src={{'/assets/icon-saws.jpeg' | relative_url}} class="icon-user saws" alt="SAWS"/>
                      <img src={{'/assets/icon-isenes.png' | relative_url}} class="icon-user isenes" alt="ISENES"/>
                      <img src={{'/assets/icon-ncfas.png' | relative_url}} class="icon-user ncfas" alt="NCFAS"/>
                      <img src={{'/assets/icon-esiwace.png' | relative_url}} class="icon-user esiwace" alt="ESIWACE"/>
                    </a>
                </div>
              </div>
            </div>
          </div>
        </div>


    <div class="flex" aria-label="Content">
      <div class="container herounit">

        <div class="flex flex--vertical content">

						<p>Cylc is a <b>general purpose workflow engine</b> that <b>orchestrates
								cycling workflows very efficiently</b>. It was designed
							for production weather, climate, and environmental
							forecasting systems, but it is not specialized to those domains
							and is completely agnostic to the applications it manages.</p>

						<p><a href="documentation#publications">
								H. Oliver et al., <i>“Workflow Automation for Cycling Systems:
										The Cylc Workflow Engine”</i>, <b>Computing in Science
										& Engineering Vol 21, Issue 4, July/Aug 2019</b>. DOI:
								10.1109/MCSE.2019.2906593</a></p>

						<!--
						<p>Cylc was designed at <a href="http://www.niwa.co.nz/">NIWA</a> to
						manage climate, weather, and environmental forecasting workflows; but
						it is not specialized to these domains and is completely agnostic to
						the applications it manages. It is now an active collaboration
						between <a href="http://www.niwa.co.nz/">NIWA</a>, <a
								href="http://www.metoffice.gov.uk/">Met Office</a>, and <a
								href="#logos">OTHERS</a>, and is a critical component of the
						infrastructure that supports the Met Office Unified Model
						system.</p>
						-->
        </div>

        <div class="flex flex--vertical release jc-space-around">
            <div class="flex flex--vertical">
          <div class="flex download-buttons">
            <div class="flex flex--vertical m-r">
              <label>Production</label>
              <a class="flex grow" id="cylc7-button">
                <button class="button flex grow">
                    <img src={{'/assets/icon-download.svg' | relative_url}} />
                    <span id="cylc7-latest-release-name"></span>
                </button>
              </a>
              <label id="cylc7-latest-release-pubdate-text"></label>
            </div>

            <div class="flex flex--vertical m-l">
                <label>Preview</label>
                <a class="flex grow" id="cylc8-button">
                  <button class="button flex grow">
                    <img src={{'/assets/icon-download.svg' | relative_url}} />
                    <span id="cylc8-latest-release-name"></span>
                  </button>
                </a>
                <label id="cylc8-latest-release-pubdate-text"></label>
              </div>
          </div>

              <h3 class="flex jc-center">Next Release:&nbsp;
                <a class="page-link" id="milestone-url" target="_blank"><span id="milestone-version"></span> (<span id="progress-info"></span>)</a>
              </h3>
              <div class="flex">
                <div class="progressbar" id="milestone-container">
                  <div class="progress" id="progress"></div>
                  <div class="flex label jc-space-between">
                    <span>0%</span>
                    <span>100%</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
      </div>
    </div>

		<div class="flex usecase bg-grey">
				<div class="container flex--vertical">
						<div class="flex screenshot wrap">
								<div class="flex flex--vertical grow shrink desc">
										<h3 class="flex">Cylc Does Cycling Properly</h3>
										<div class="flex flex--vertical">
												<p>Cylc does not merely repeat-run a workflow
												(immediately, or on a real time schedule). It "unwinds
												the loop" to create a single potentially infinite
												non-cycling workflow composed of repeating tasks.
												Consequently:</p>
											 <ul>
													<li>Cylc can interleave cycles for fast catch-up from
													delays, and sustained high-throughput off the clock</li>
													<li> It seamlessly transitions between fast catch-up
													and clock-limited real-time scheduling</li>
													<li>It supports multiple cycle intervals within a single
													workflow</li>
												</ul>
										</div>
								</div>
								<div class="flex grow shrink image">
										<a href="{{'/assets/img/cycling.png' | relative_url}}">
												<img style="width:100%; margin-top:40px"
												src="{{'/assets/img/cycling-trans.png' | relative_url}}">
										</a>
								</div>
						</div>
				</div>
		</div>

		<div class="flex">
        <div class="container flex--vertical">

						<h3>Why Another Workflow Engine?</h3>

						<p><b>Production Ready:</b>
						Cylc is not just a research tool. It has been used 24/7 since 2010
						for production weather forecasting - which is notorious for the size
						and complexity of its application workflows.</p>
						<br/>

						<p><b>Efficient Cycling:</b>
						On deployment to NIWA production systems Cylc's automatic cycle
						interleaving cut ~24 hours of catch-up from delays down to ~30
						minutes. (This is the original reason for Cylc. It also predates
						some current non-cycling systems).</p>
						<ul>
								<li> <i>ISO 8601 cycling</i> supports any date-time sequence
								for weather and climate workflows
								<li><i>integer cycling</i> supports arbitrary repetitive
								workflows (e.g. satellite data processing).
						</ul>
						<!--<p>If there is no cross-cycle dependence Cylc runs
						multiple cycles concurrently, limited only by external
						resource and configurable internal constraints.</p>-->
						<br/>

						<p><b>Open Source:</b>
						Cylc is available on the GPLv3 license and is actively and openly
						<a href="https://github.com/cylc">developed on GitHub</a>.</p>
						<br/>

						<p><b>Distributed Architecture:</b>
						There are no central workflow or database servers to manage, so
						Cylc has low admin overhead and a small security footprint. Each
						workflow gets its own ad hoc server program, which runs as the
						user, and only relies on the filesystem. </p>
						<br/>

						<p><b>Cross-workflow Triggering:</b>
						Via the upstream workflow database, so the upstream workflow
						doesn't even have to be running at the time.</p>
						<br/>

						<p><b>Distributed Workflows:</b>
						Cylc easily manages task jobs on multiple remote hosts.</p>
						<br/>

						<p><b>Workflow Configuration:</b>
						A human-readable config file, so modest workflows are easy to
						write, even for non-programmers. This is <b>not</b> <i>"just a
								static config file"</i> however: efficient programmatic
								generation of
				    large complex workflows is supported by task inheritance and
						parameterization, and Python-like general template processing. (A
						Python API is also planned for Cylc 9).</p>
						<br/>

						<p><b>Workflow Scaling:</b>
						Single workflows scale to thousands of tasks per cycle (however,
						Cylc is a distributed system so several smaller workflows may be
						preferred).</p>
						</br/>

						<p><b>System Scaling:</b>
						Cylc is built to transparently use a pool of host VMs, with
						load balancing at start-up, and it scales arbitrarily well with the
						number of host VMs. Running workflows can self-migrate to another
						host at maintenance time. </p>
						<br/>

						<p><b>Powerful UIs:</b>
						GUIs for workflow visualization, and runtime monitoring and control
						(GTK for Cylc 7; a web UI for Cylc 8, coming next year). The CLI
						can flexibly operate on many tasks at once, e.g. to re-trigger
						all failed tasks matching a certain name pattern in a particular
						cycle point.</p>
						<br/>

						<p><b>Flexibility and Generality:</b> Cylc can be used equally for
						every kind of workflow in climate, weather, and weather-driven
						forecasting (for example), in research, test, and production.
						Portable workflows are feasible that run "out of the box" in
						different environments; and even at different sites. This can lead
						to huge savings: transitioning complex systems from research to
						operations, for instance, is notoriously difficult if the workflows
						are different; and much worse again if conversion to a different
						workflow engine is required.</p> <br/>

						<p><b>HPC:</b>
						Cylc has great support for common HPC batch systems (workload
						managers) like PBS and Slurm. It can also manage plain background
						jobs on any Linux host.</p>

						<p><b>Remote Job Hosts:</b>
						If you need to use ssh to reach a remote job host, Cylc supports
						that as well. This includes remote job query and kill, filesystem
						configuration and file installation, and job log retrieval. (Some
						of this is via Rose but soon to be built in to Cylc).</p>
						<br/>

						<p><b>General External Triggering:</b>
						Trigger tasks off of anything in the external world - just supply a
						Python function that checks your external condition.</p>
						<br/>

						<p><b>Resilience:</b>
						Cylc has many features to help deal with system problems, e.g.:</p>
						<ul>
								<li> configurable retries for both job submission and job
								execution
								<li> state checkpointing, with safe restarts even in the event
								of a power outage (Cylc even determines what happened to
								jobs orphaned during downtime)
								<li> polling to confirm that jobs are still queued or running
								as expected (if not, job status is updated accordingly)
								<li> manual job control: poll, kill, or retrigger jobs
								<li> failure (and other state) triggering - e.g. define tasks
								that only run if other tasks fail
								<li>flexible event handling - connect handler scripts to
								many events (such as task failure); and built-in email alerting
						</ul>
						<br/>

						<p><b>Other Capabilities in Brief:</b>
						</p>
						<ul>
								<li> Powerful web-based viewer for thousands of job logs
								<li> Validation - catch many errors prior to run time.
								<li> Edit Run - edit job scripts on the fly just before submission.
								<li> Broadcast task runtime settings (including environment variables) to
								tasks or groups of tasks, at runtime.
								<li> Simulation modes with proportional job run length.
								<li> Internal Queues to limit the number of concurrent active
								tasks.
								<li> Conditional triggering.
								<li> Clock-triggers - trigger off the clock as well as off other tasks.
								<li> External triggers - trigger off external events as well as
								other tasks - via user-defined Python plug-in functions.
								<li> Expiring tasks - optionally skip tasks that are too far
								behind the clock.
						</ul>

        </div>
      </div>

		<div class="flex">
        <div class="container flex--vertical">
            <h3>Publications</h3>
						<p><b>If you use Cylc</b> please <a
								href="documentation#publications">cite it in your
								publications</a> and <a href="community#user-support">let us
						know</a> if your organization should be <a
				href="community#sites-using-cylc">listed on this website</a>.
						</p>

            <p>
              <b>
                Workflow Automation for Cycling Systems: The
                Cylc Workflow Engine
              </b>
              <br />
              H. Oliver et al
              <br />
              <em>
                Computing in Science & Engineering Vol
                21, Issue 4, July/Aug 2019. DOI: 10.1109/MCSE.2019.2906593
              </em>
              <br />
              <a
               href="https://doi.org/10.1109/MCSE.2019.2906593"
              >
                DOI: 10.1109/MCSE.2019.2906593
              </a>
            </p>

            <p>
              <b>
                Cylc: A Workflow Engine for Cycling Systems
              </b>
              <br />
              Oliver et al., (2018).
              <br />
              <em>
                Journal of Open Source Software, 3(27), 737.
                DOI: 10.21105/joss.00737
              </em>
              <br />
              <a
               href="https://doi.org/10.21105/joss.00737"
              >
                <img
                 src="http://joss.theoj.org/papers/10.21105/joss.00737/status.svg"
                />
              </a>
              <br />
            </p>

            <p>
              <b>
                Citable DOI for Cylc code releases.
              </b>
              <br />
              <a
               href="https://zenodo.org/badge/latestdoi/1836229"
              >
                <img
                 src="https://zenodo.org/badge/1836229.svg"
                />
              </a>
            </p>
        </div>

        <div class="container flex--vertical">
        </div>
      </div>

    {%- include header.html -%}
    <script type="text/javascript">
      "use strict";

      // --- HTTP request
      /**
       * The GitHub URL for the milestones.
       * @const {string}
       */
      const MILESTONES_URL = "https://api.github.com/repos/cylc/cylc/milestones";
      /**
       * The GitHub URL for the releases.
       * @const {string}
       */
      const RELEASES_URL   = "https://api.github.com/repos/cylc/cylc/releases";
      /**
       * The GitHub URL for the tags.
       * @const {string}
       */
      const TAGS_URL = "https://github.com/cylc/cylc-flow/releases/tag/";
      /**
       * Send HTTP GET request, and invoke callback after upon response. If
       * it contains the GitHub API message, the callback is not invoked, but
       * instead it is logged ot the console as an error.
       * @param {string} url - The URL to send GET request.
       * @return {Promise} A promise.
       */
      function doGet (url) {
        return new Promise(function(resolve, reject) {
          const xhr = new XMLHttpRequest();
          xhr.open("GET", url);
          xhr.onload = function () {
            const milestones = JSON.parse(this.response);
            // GitHub API returns {documentation_url: "", message: ""} messages for rate limiting
            // see https://developer.github.com/v3/#rate-limiting
            // and https://github.com/cylc/cylc.github.io/issues/15
            if (Object.prototype.hasOwnProperty.call(milestones, 'message')) {
              // will be logged in the .catch block of the promise call
              reject(milestones.message);
            } else {
              resolve(milestones);
            }
          };
          xhr.onerror = function () {
            reject(xhr.statusText);
          };
          xhr.send();
        });
      }
      // --- Cache
      /**
       * Cache keys prefix constant.
       * @const {string}
       */
      const CACHE_KEY_PREFIX = 'cylc.progress.cached.';
      /**
       * Cache timeout constant (in seconds).
       * @const {number}
       */
      const CACHE_TIMEOUT_SECONDS = 60 * 60; /* 1 hour, 60 minutes times 60 seconds */
      /**
       * A cache that uses the browser LocalStorage. Values are stored for
       * a limit timeout. Once this timeout expires, the value is removed
       * from the cache and null is returned.
       */
      class Cache {
        /**
         * @param {number} timeout - The cache timeout expiration in seconds.
         */
        constructor(timeout) {
          this.timeout = timeout;
          this.storage = window.localStorage;
        }
        /**
         * Simply puts the value in the LocalStorage, replacing any previous value.
         * @param {string} key - The cache key.
         * @param {string} value - The value to be cached. This value will be serialized as a JSON string.
         */
        put(key, value) {
          const cached = {
            value: value,
            created: new Date().getTime()
          };
          // we always store strings in the LocalStorage, that is the reason for the JSON.stringify call
          this.storage.setItem(`${CACHE_KEY_PREFIX}${key}`, JSON.stringify(cached));
        }
        /**
         * Get the cached value if in the cache and not expired. Otherwise returns null.
         * @param {string} key - The cache key.
         * @returns {(null|Object)} Either the value cached, or null if nothing was found.
         */
        get(key) {
          try {
            const cachedJson = this.storage.getItem(`${CACHE_KEY_PREFIX}${key}`);
            if (cachedJson === null || cachedJson === undefined) {
              return null;
            }
            const cached = JSON.parse(cachedJson);
            const created = cached.created;
            const now = new Date().getTime(); // ms
            const expired = created + (this.timeout * 1000) <= now;
            // still valid, return it immediately
            if (!expired) {
              return cached.value;
            }
            // expired, remove from cache
            this.storage.removeItem(`${CACHE_KEY_PREFIX}${key}`);
            return null;
          } catch (e) {
            // e.g. SecurityError if using file:///...
            console.error(e);
            return null;
          }
        }
      }
      /**
       * A cache to prevent hitting the GitHub API unnecessarily.
       * @const {Cache}
       */
      const CACHE = new Cache(/* timeout in seconds */ CACHE_TIMEOUT_SECONDS);


      // --- Progress

      /**
       * Get the next release from a set of milestones. The next release is the milestone with the earliest due date.
       * @param {Array} milestones - array of milestone objects
       * @return {Object} The milestone with the earliest due date, or null if milestones empty.
       */
      function getNextRelease(milestones) {
          // Sort the milestones by due date
          if (!milestones) {
            console.error("Invalid milestones value");
            return null;
          }
          if (milestones instanceof Object) {
            // GitHub API returns {documentation_url: "", message: ""} messages for rate limiting
            // see https://developer.github.com/v3/#rate-limiting
            // and https://github.com/cylc/cylc.github.io/issues/15
            if (Object.prototype.hasOwnProperty.call(milestones, 'message')) {
              console.error(milestones.message)
              return null;
            }
          }
          milestones.sort((a, b) => a.due_on < b.due_on ? -1 : a.due_on > b.due_on ? 1 : 0);
          return milestones[0];
      }
      /**
       * Populate progress elements in the DOM.
       *
       * @param {number} openIssues - An integer with the number of open issues.
       * @param {number} closedIssues: An integer with the number of closed issues.
       * @param {string} title - The title of the next release.
       * @param {string} link - A URL link to the next release.
        */
      function populateProgress(openIssues, closedIssues, title, link) {
          const workProgress = closedIssues * 100 / (openIssues + closedIssues);

          const milestoneVersion = document.getElementById("milestone-version");
          milestoneVersion.innerHTML = title;

          const milestoneURL = document.getElementById("milestone-url");
          milestoneURL.setAttribute('href', link);

          const progressBarInner = document.getElementById("progress");
          progressBarInner.style.width = workProgress + "%";

          const progress = document.getElementById("progress-info");
          progress.innerHTML = Math.floor(workProgress) + "%";

          const milestoneContainer = document.getElementById("milestone-container");
          milestoneContainer.style.opacity = "1";
          milestoneContainer.style.transition = ".7s ease-in";
      }

      /**
       * @param {Object} milestones - The list of milestones.
       */
      function showProgress(milestones) {
        const nextRelease = getNextRelease(milestones);
        if (nextRelease) {
          const openIssues = nextRelease.open_issues;
          const closedIssues = nextRelease.closed_issues;
          const title = nextRelease.title;
          const link = nextRelease.html_url.replace('s/next%20release', '/' + nextRelease.number);
          populateProgress(openIssues, closedIssues, title, link);
        }
      }

      /**
       * Retrieve the milestones (progress) of the project.
       * @return {Promise} A Promise object that populates and creates DOM elements, or returns the status text on error.
       */
      function retrieveProgress() {
        const milestones = CACHE.get('milestones');
        if (milestones !== null) {
          return new Promise(function () {
            showProgress(milestones);
          })
        } else {
          // fetch from GitHub API
          return doGet(MILESTONES_URL).then(function (milestones) {
            CACHE.put('milestones', milestones);
            showProgress(milestones);
          })
        }
      }

      // --- Releases

      /**
       * Populate HTML elements with information about the latest release.
       *
       * @param cylcx {string} - 'cylc8' or 'cylc7'
       * @param name {string} -  name of the release
       * @param link {string} - URL of the release
       * @param publishedAt {string} - raw text date as returned from the API
       */
      function populateLatestReleaseInformation(cylcx, name, link, publishedAt) {
        const latestReleaseName = document.getElementById(cylcx + "-latest-release-name");
        latestReleaseName.innerHTML = name;

        const latestReleaseURL = document.getElementById(cylcx + "-button");
        latestReleaseURL.href = link;

        const latestReleaseDateText = document.getElementById(cylcx + "-latest-release-pubdate-text");
        latestReleaseDateText.innerHTML = `Released: ${publishedAt}`;
      }

      /**
       * @param release {{
       *   name: String,
       *   published_at: String,
       *   tag_name: String
       * }}
       * @return {string} - Release date formatted as M/D/Y (e.g. 5/14/2020).
       */
      function getReleaseDate (release) {
        return new Date(release.published_at).toLocaleString().split(',')[0]
      }

      /**
       * @param {[
       *   {
       *     name: String,
       *     published_at: String,
       *     tag_name: String
       *   }
       * ]} releases - The list of releases.
       */
      function showReleases(releases) {
        // show latest Cylc 7 release
        const latestCylc7 = releases
          .filter(release => release.name.startsWith("cylc-7.9"))
          .sort((left, right) => new Date(left.published_at) - new Date(right.published_at))
          .pop()
        if (latestCylc7) {
          populateLatestReleaseInformation(
            "cylc7",
            latestCylc7.name,
            `${TAGS_URL}${latestCylc7.tag_name}`,
            getReleaseDate(latestCylc7))
        }

        // show latest Cylc 8 release
        const latestCylc8 = releases
          .filter(release => release.name.startsWith("cylc-flow-8"))
          .sort((left, right) => new Date(left.published_at) - new Date(right.published_at))
          .pop()
        if (latestCylc8) {
          populateLatestReleaseInformation(
            "cylc8",
            latestCylc8.name,
            `${TAGS_URL}${latestCylc8.tag_name}`,
            getReleaseDate(latestCylc8))
        }
      }

      /**
       * Retrieve the releases of the project.
       * @return {Promise} A Promise object that populates and creates DOM elements, or returns the status text on error.
       */
      function retrieveReleases() {
        const releases = CACHE.get('releases');
        if (releases !== null) {
          return new Promise(function () {
            showReleases(releases);
          })
        } else {
          return doGet(RELEASES_URL).then(function (releases) {
            CACHE.put('releases', releases);
            showReleases(releases);
          })
        }
      }

      // --- window.onload

      /**
       * Called when the browser loads the page. It will execute two promises asynchronously,
       * one to retrieve the progress, and the other to retrieve the releases.
       * If an error occurs, it will print the error to the browser console.
       */
      window.onload = function () {
        Promise.all([
          retrieveProgress(),
          retrieveReleases()
        ])
          .catch(function(error) {
            // Any error propagated here will be logged to the browser console
            console.log(error);
          });
      };
      </script>

  </body>

</html>
